Qustpond

--bin/Debug/application_name
final set of dll complete code with exe file
final assembly deployed as application

--obj
each changes the compilation data stored as dlls 
each class different dll's maintained which helps application to run specific project inside solution.when multiple projects present in solution

--CTS
cts will make sure when project contains multiple languages like c#.F#,vb then it 
will make the jit to combile the code to same machine level code when we specify datatype on different program different way
hence multi language support achieved on .net


--CLS
cls take care of common rules on specific programming language like naming convensions and all
if user violted it means it will not make the application to run without warning

Casting

            double temp1 = intnumbers;
            Console.WriteLine("****** type casting implicit ******" + temp1);

            int temp2 = (int)doublenumber;
            Console.WriteLine("****** type casting explicit ******" +temp2);

----------------------------------------------------------------------------------------------------------------

class -  blueprint
functions - all methods are functions but static methods are specifically mentioned as functions as not related to object
methods - all methods/functions related to class or can be invoked by creating object of that class is method

Variable: A temporary data holder declared inside a method, used only within that method.

Field: A class-level variable that holds data for an object or class.

Property: A class member that provides controlled access to fields using get and set. eg : public string Name { get; set; }

Value type (stack storage) 
int i = j;
Reference type
Class obj1 = new Class();
obj1 = 2323;
Class obj2 = new Class();
obj2 = obj1;
obj2 = 987;

so now obj1 also 987 as when we mention obj2 = obj1 we are passing memory adderss or reference so changes affect both;
What happened here is in stack obj1,obj2 may have different pointer address but on heap memory address of both will be same here
Reference type values data are stored on heap hence one change might affect both.

struct is same as class but its value type.


---------------------------------------------------------------------------------------------------

--STACK is ram type memory where value type data is stored and will remove from memory at end of the scope of the variable {}
--HEAP is memory space where reference type values are being stored and these values wont erase after the variable scope.
--Garbage Collector used here to remove the data from heap.
 So if pointer reference of data on heap is not present on stack then garbage collector will remove that data.
 
 
---------------------------------------------------------------------------------------------------

Array

same data type set of data

int[] array = new int[5] {1,2,3,4,5};

can add using array[0] = 67;


---------------------------------------------------------------------------------------------------
import system.collections

ArrayList
multi data types allowed 

ArrayList li = new ArrayList();
li.Add(34);
li.Add("sru");

here 34,sru are taken as object to the arraylist hence boxing happening here from int/string to object 
so arraylist performance is low as every input converted to object

---------------------------------------------------------------------------------------------------
generics collections

import System.Collections.Generic


LIST -  have both benefit of array and arraylist

List<string> userDetails = new List<string>();
userDetails.Add("raja");


----------

Thread (Thread used to implement parellelism in cpu each core do each work)

Thread t1 = new Thread(FunctionName());

t1.Start(); -- to start the thread
t1.Join();  -- makes thread1 to finish before next thread to start

here Join used to keep t1 alive if its background thread. CLR kills the background threads immidiatey.
Main is the main thread here and threads created with new thread is Foreground threads those will run as normal
But threads created with threadpool/Task base threads area background and needs Join to keep it alive else main only execute without thread content(t1.IsBackground = true;)

--------

Task Parallet Library and threads

Task t = new Task(T)
Task.Delay(1000);
async and await keys not create threads it consider as single thread and it implement asynchronism

async and await 

public async static void Function3()
{
    for(int i = 0;  i < 100; i++)
    {
        await Task.Delay(1000);
        Console.WriteLine("function 3 "+i);
    }
}

Note: I/o wait or http request or web application gui change use async and await
For cpu threading and tpl usage to make complex data processing use Task

I/O Writing

string path = @"G:\sample.txt";
File.WriteAllText(path,"sudeesh");
string filecontent = File.ReadAllText(path);
Console.WriteLine(filecontent);

Console.WriteLine("--------------");
string path2 = @"G:\";

Console.WriteLine($"the path is {path2} and folder cound is"+Directory.GetDirectories(path2).Length);
Console.WriteLine("and the file count is  : "+Directory.GetFiles(path2).Length);



---------------------


Linq    ------> Language integrated query

 LINQ Method Syntax 

custlist
    .Where(cust => cust.Country == "India")
    .ToList()
    .ForEach(cust => Console.WriteLine(...));
	

LINQ Query Syntax



var item = (from custitems in custlist
             where custitems.Country == "India"
             select custitems).ToList<Customer>();
			 
			 
Traditional foreach loop			 
			 
foreach (Customer customer in item)
{
    if (customer.Country == "India")
    {
        Console.WriteLine(...);
    }
}


Enums

here rather than using numbers like case 2342252: we used case BankIFSC.Perambur: hence we are not hardcoding values
Group of constants are mentioned in form of Enums

           const double PiValue = 22.3; //reassign not allowed

           //When list of constants required to be used use enums

           int number = int.Parse(Console.ReadLine());

           BankIFSC inputValue = (BankIFSC)number;

           switch (inputValue)
           {
               case BankIFSC.OtteriBranch:
                   Console.WriteLine("welcome to otteri branch");
                   break;
               case BankIFSC.Purasaiwalkam:
                   Console.WriteLine("welcome to Purasawalkam branch");
                   break;
               case BankIFSC.Perambur:
                   Console.WriteLine("welcome to Perambur branch");
                   break;
               case BankIFSC.Central:
                   Console.WriteLine("welcome to central branch");
                   break;
               default:
                   Console.WriteLine("not welcome to  branch");
                   break;
           }


       }

       enum BankIFSC
       {
           OtteriBranch = 0000927,
           Purasaiwalkam = 000982,
           Perambur = 2353252,
           Central = 3454354
       }